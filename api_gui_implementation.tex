\chapter{Towards a new architecture}
\label{chapter:towards_new_architecture}
The discussion in Chapter \ref{chapter:architecture} concluded with a proposal of a new future-proof architecture. Now, we will shift our focus on performed efforts on making this design a reality. This will mostly involve the implementation of components that can be found on the higher levels of the proposed architecture, in particular the user interface, the REST API and \emph{libtribler}.

\section{REST API}
As described in Chapter \ref{chapter:architecture}, communication between the user interface and the Tribler core is facilitated by a REST API in our design. This Section explains the implementation of the API in more detail.\\\\
The REST API has been implemented using the Twisted library. While there are plenty of Python libraries available that allow developers to create a web server in their application, we made the choice to use Twisted since it is already utilized to a great extent by Tribler. With the ability to integrate the REST API into the main application flow, we avoid having to create special constructions to run the API on a separate thread, thus increasing complexity of the system, like we are doing with the video server. API endpoints in Twisted are represented as a resource tree. This is in accordance with REST where the URL of the request can be treated like a path in the resource tree. This tree-like structure is somewhat visible in the import graph of the API package as displayed in Figure \ref{fig:importgraph-api}. We will highlight and discuss some important files in the API package:
\begin{itemize}
	\item \emph{rest\_manager}: the \emph{rest\_manager} file contains the \emph{RESTManager} class which is responsible for starting and stopping the API. In addition, this file contains the \emph{RESTRequest} class which is a subclass of \emph{server.Request} (which in turn is instantiated by Twisted on an incoming request) and handles any exceptions that occurred during the serving of the HTTP request.
	\item \emph{root\_endpoint}: this file hosts the \emph{RootEndpoint} class which represents the root node of our resource tree. This class dispatches all incoming requests to the right sub nodes in the resource tree.
	\item \emph{util}: the \emph{util} file contains various helper functions, such as conversion utilities to easily transform channel and torrent data from the database into JavaScript Object Notation (JSON) format that can be sent to the client that initiated a request.
\end{itemize}

\begin{figure}[h!]
	\centering
	\includegraphics[width=1.0\columnwidth]{images/improving_qa/importgraph_api}
	\caption{The import graph of the REST API module.}
	\label{fig:importgraph-api}
\end{figure}

\subsection{Response Format}
Except for some endpoints that are returning a response in binary format, most data returned by the API is structured in JSON format. The JSON format is well adopted in the field of web engineering and easy to parse. Most of the endpoints are straightforward implementations where the client performs a request and some data is returned. There are situations where the client does a request and a stream of data should be returned. For instance, this is the case when the user performs a search query. Sometimes, data should be returned to the client, even if the client did not ask for this data. When a crash in the Tribler core code occurred, the client should be notified of this crash and possibly warn the user that he or she should restart the application. For this purpose, an asynchronous events stream has been designed and created. Clients can open this event stream and interesting notifications are sent over this stream. All messages that are sent over the \emph{events} connection are shown in Table \ref{table:rest-api-events}.\\

\begin{table}
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{Event name} & \textbf{Description} \\ \hline
		\emph{events\_start} & The events connection is opened and the server is ready to send events.  \\ \hline
		\emph{search\_result\_channel} & Tribler received a channel search result (either remote or locally). The event contains the channel result data. \\ \hline
		\emph{search\_result\_torrent} & Tribler received a torrent search result (either remote or locally). The event contains the torrent result data. \\ \hline
		\emph{upgrader\_started} & The Tribler upgrader started. \\ \hline
		\emph{upgrader\_tick} & The status of the Tribler upgrader changed. This event contains a human-readable string with the status update. \\ \hline
		\emph{upgrader\_finished} & The Tribler upgrader finished. \\ \hline
		\emph{watch\_folder\_corrupt\_torrent} & The watch folder module has encountered a corrupt .torrent file. The name of the file is part of this emitted event.\\ \hline
		\emph{new\_version\_available} & A new version of Tribler is available. The version number is contained in the event.\\ \hline
		\emph{tribler\_started} & Tribler has completed the startup procedure and is ready to serve HTTP requests on all endpoints.\\ \hline
		\emph{channel\_discovered} & A new channel has been discovered. The events contains the discovered channel data.\\ \hline
		\emph{torrent\_discovered} & A new torrent has been discovered. The events contains the discovered torrent data.\\ \hline
	\end{tabularx}
	\caption{An overview of all events that are passed over the asynchronous events connection, part of the REST API.}
	\label{table:rest-api-events}
\end{table}

\subsection{Error Handling}
A proper designed API should have a mechanism to notify users about any internal errors that occurred during requests. Our API returns HTTP response code 500 (\emph{internal server error}) when we observe a Python exception. Moreover, we return a JSON-encoded response that contains more specific  information about the caught exception such as the name of the exception, whether the error has been handled by the core and optionally, the stack trace of the exception. An example of an error response is displayed in \ref{lst:error-api-json}.

\begin{lstlisting}[caption={The response in JSON format returned when a Python exception is observed during the processing of an API request.},label={lst:error-api-json}]
{
  "error": {
    "message": "integer division or modulo by zero",
    "code": "ZeroDivisionError",
    "handled": false,
    "trace": [
        " File \"/Library/Python/2.7/site-packages/twisted/web/server.py\", 
        line 183, in process\n    self.render(resrc)\n", 
        ...
    ]
  }
}
\end{lstlisting}

\section{Graphical User Interface}
The amount of accumulated technical debt in the current graphical user interface of Tribler is devastating. After going through several development cycles where some impacting changes to the user interface have been made, the code base has reached the point where it might be more beneficial to create a complete new user interface. 29,3\% of the Tribler code base, excluding Dispersy, is related to the user interface. We now will continue the discussion that has been initiated in Section \ref{chapter:problem-description} regarding the architecture of the user interface module. First, the structure of the current interface will be described. We will make the consideration between refactoring efforts of the existing user interface or creating a new one. Additionally, encountered design decisions and challenges are presented and discussed.

\subsection{Analysis of the current user interface}
The user interface of the latest version of Tribler, 6.5.2, is unintuitive and cluttered with unused and unnecessary widgets. There are various spelling errors and the navigation through the interface is complex. There are no clear instructions for users that are starting the interface for the first time. For instance, when users are starting Tribler for the first time, there is no information about content that is being discovered. To provide a better user experience, we could provide an indicator about the amount of discovered content.\\\\
When focussing on the code base, we notice that it is full of undesired workarounds and bad coding practices (code smells). Much functionality that should be located in the core module of Tribler, is present in the code of the user interface package. There is no clear, documented structure to be identified throughout the code and several reasons for this issue exists. One of the underlying causes is the mindset of developers that the code base of the user interface is subordinate to the code related to core functionalities of Tribler. While it is often true that minor defects in the user interface are less critical than errors in critical core functionalities such as the download engine, developer should always strive to write maintainable and well-designed code, a responsibility which is clearly neglected by user interface developers of Tribler. The fact that the user interface has undergone dramatic changes throughout the ten years of research is an additional reason that led to this unstructured code base. Making short-term decisions were favoured over decisions that benefit the longer-term development process, leading to accumulated amounts of technical debt.\\\\
By taking a closer look at the structure of the user interface code base, several files with many class definitions can be found. We already presented the import graph of the user interface code base in Figure \ref{fig:wx-import-graph} where we identified many cyclic dependencies. While cyclic dependencies are not always undesired at the granularity of a class file, we are dealing here with a web of dependencies between files, each file possibly consisting of multiple class definitions. Automated testing of individual classes has become significantly more involved with these dependencies.\\\\
We now turn our attention to the layout of user interface, where we use the \emph{wx} inspection tool to investigate the structure of the interface at runtime. We noticed here that the naming convention of widget elements is unclear. For instance, the \emph{ActivityListItem} class is representing a list item in the left menu of Tribler, however, this has nothing to do with an activity that the user performs.\\\\
We noticed that the developers of user have attempted to reuse widget elements, especially noticeable in list-related widgets such as headers, footers and list row items. However, we think this can be classified as a failed attempt since the amount of flexibility is too much: by making widgets look good in many different situations in the user interface, the complexity of the class definition increases due to the amount of conditional code that is only executed in a subset of all situations. However, by using the same widget throughout the user interface, we are creating a consistent look and feel.\\

It is hard for developers to get familiar with the code base of the user interface and to modify it. We think the most appropriate metaphor of the user interface code base is a big ball of mud:

\begin{displayquote}
	\emph{A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated. The overall structure of the system may never have been well defined. If it was, it may have eroded beyond recognition. Programmers with a shred of architectural sensibility shun these quagmires. Only those who are unconcerned about architecture, and, perhaps, are comfortable with the inertia of the day-to-day chore of patching the holes in these failing dikes, are content to work on such systems.}\\
	- Brian Foote and Joseph Yoder, Big Ball of Mud\cite{foote1997big}.
\end{displayquote}

We think that it is not worth the effort to refactor the current user interface and that it is better to start creating a new user interface that follows clear architecture and design principles. However, while designing a new interface, we should still fix critical issues in the old, current user interface. By guaranteeing a minimal level of maintenance of the current GUI, we are not under time pressures to ship the new interface in a specific release of Tribler. Only when the new user interface is ready, stable and tested, we will remove the old interface.

\subsection{Choosing the right library}
Before designing and implementing the new interface, we should first decide which library we would like to use. Because our proposed architecture in Figure \ref{fig:tribler7} is communicating to \emph{libtribler} using a RESTful API, this library does not necessary has to support the Python programming language. However, to make reuse of code easier and to maintain a consistent system which used the same programming language for all components, we will implement our new user interface in Python, There are plenty of libraries that are suitable. Below, several of such libraries are summarized, together with a small description.
\begin{itemize}
	\item \emph{wxPython}\cite{rappin2006wxpython}: this is the current user interface library we are using. \emph{wxPython} is built upon \emph{wxWidgets} and provides the Python bindings to this latter library. The library is cross-platform and we can continue to use \emph{wxPython}. We already have a large code base written in \emph{wxPython} so continued usage of this library could allow us to reuse several widgets. The main disadvantages of this library are the minor inconsistencies across different platforms and the lack of a visual designer, requiring us to specify the complete layout in Python code.
	\item \emph{Kivy}\cite{solis2015kivy}: the cross-platform library Kivy has been used by Tribler research, particularly in the past attempts to run Tribler on Android\cite{de2014android}\cite{sabee2014tribler}. The decision of using Kivy for the new user interface enables us to reuse the interface logic on Android. The layout of Kivy can either be created in \emph{.kv} files or specified in code which is based on the separation of concerns principle. While not as old as \emph{wxPython} or \emph{pyQt}, the library has gained significant attention and adoption in the Python community.
	\item \emph{Tkinter}\cite{lundh1999introduction}: the \emph{Tkinter} library is a layer built upon the Tcl/Tk framework and is considered the de-facto graphical user interface library for Python. Like the other discussed frameworks, \emph{Tkinter} does not provide a visual designer. The library is built-in in Python which means that no additional libraries have to be installed in order to start writing code. \emph{Tkinder} however is considered more suitable for simple applications due to the simplistic nature of the library.
	\item \emph{PyQt}\cite{summerfield2007rapid}: \emph{PyQt} provides the Python bindings for the Qt framework and is widely used in open-source and commercial applications. With a first version released in 1995, the Qt framework has evolved into a mature state. The library is very well documentation and provides many different addons and plugins to support a wide range of applications. One of these plugins is a visual WYSIWYG designer where the layout of an interface can be specified in a drag-and-drop manner. This generates a \emph{xml} file which can be read and parsed by \emph{Qt}. Visual styles can be specified using the  \emph{Cascading Style Sheet} (CSS) language. The documentation of \emph{Qt} is very comprehensive, although the documentation regarding \emph{PyQt} is somewhat less maintained.
\end{itemize}
Since the GUI will be an important aspect of Tribler, we wish to use a library that is mature, future-proof, well-maintained, easy to use and offers a large of tools so we can reduce the amount of code that has to be maintained. We think that in the context of this thesis, choosing \emph{PyQt} is the best choice to build a new user interface. The fact that we can specify our layout using an editor is an enormous advantage since this will mean that we have less code to maintain. In addition, this allows other developers that are not familiar with the Tribler code base to contribute to the graphical user interface. The \emph{Qt} visual designer also offers tools for internationalization and translation of the interface in foreign languages. Tasks like these are perfect opportunities for contributions in an open source project and can potentially attract new developers. A screenshot of the used visual designer in Qt is visible in Figure \ref{fig:qt-visualizer}.

\subsection{Designing the new interface}
Designing a user-friendly interface is a non-trivial task and creating a proper design together with mock-ups, is a thesis task itself. Since the design of the new user interface is important but should not be the main focus of this work, we decide to adopt various design principles of existing applications that contain somewhat similar use-cases of Tribler.\\\\
In 2008, two design studies have been conducted on the Tribler user interface by two groups of master students\todo{beschrijven}.\\\\
Most torrent download applications have a similar interface: they present a list with downloads and a detail window with specific information about a selected downloads. The old user interface also follows this pattern when displaying the downloads and we see no reason for now to make significant changes to this page. However, Tribler provides more abilities than downloading torrents: browsing through content and managing channels are also use-cases that should be considered in the design.\\\\
We believe that YouTube is an example of application that comes close to our use-cases, namely the browsing and streaming of videos, creating and managing channels and creating playlists. The home page of the YouTube interface is visible in Figure \ref{fig:youtube-interface}. We take over the left menu in our design like in the current interface, however, we modify it slightly: first, we add an option to open and close the menu by clicking the hamburger menu in the upper-left corner. Next, we make more use of icons so users can identify faster what each option is doing. The adoption of more icons is a general trend in the new user interface: we think that the old interface is too textual.\\\\
To make the visual more appealing, we attach a thumbnail to each content item. There is however an issue here: the thumbnails as implemented in the current system is not working correctly. Since implementing a new thumbnail mechanism is outside the scope of this thesis, we use thumbnails that are generated based on the content. This is a technique also adopted by popular platforms such as Stack Overflow and Telegram to display a profile image when the user has not uploaded a picture yet.\\\\
Finally, we want to get rid of 'hidden' buttons that are only appearing when hovering over content like is the case in the old user interface. To make it more clear that a specific action can be performed with content, we do not conditionally hide and show buttons but instead, persistently display these widgets.\\\\
Due to time constraints, we decided to not implement all features of the old interface. Functionalities such as the debug panel, local filtering and sorting of content will not be implemented in the first iteration of the new user interface. The focus of this new interface will be centred around searching for and downloading content.

\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\columnwidth]{images/implementation/youtube_interface}
	\caption{The interface of YouTube.}
	\label{fig:youtube-interface}
\end{figure}

\subsection{Implementing the new interface}
The result after implementation of the new user interface is visible in Figure \ref{fig:new-gui-1}. Our vision during development of this interface is that in essence, it should only display data and do as few processing operations on this data as possible. The majority of the new user interface has been built using the visual designer, part of \emph{Qt}. The written Python code is centred around handle requests to the Tribler core, display of the right data in lists and to manage interface-related settings.\\

\begin{figure}[t]
	\centering
	\includegraphics[width=1.0\columnwidth]{images/improving_qa/newgui1}
	\caption{The home page of the new user interface.}
	\label{fig:new-gui-1}
\end{figure}

A key feature of the \emph{Qt} library is the signal-slot mechanism which facilitates communication between code and widgets. Widgets in \emph{Qt} can have signals, events they want to broadcast to other widgets. Some widgets have built-in signals, for instance, a button emits a \emph{clicked} signal if the user clicks on this widget with the mouse. Other widgets or objects in Python can subscribe to these signals and perform some specified actions when the signal is observed.  Signals and slots can either be created by hand, using code, or by utilizing the visual designer. To keep the amount of code to be maintained to a minimum, we decided to specify our widgets connections in the visual designer as much as possible.\\\\
During development of the user interface, we encountered some implementation challenges that required more analysis. We will now present these issues and discuss them.

\subsubsection{\textbf{Scalability of list items}}
The \emph{Qt} framework allows to display potentially many items in a simple list. The performance decreases dramatically if custom widgets are rendered in a list, like we are doing. Loading 1.000 of such list items takes over 22 seconds on a high-end iMac device, introducing an unacceptable amount of latency when displaying a list of items. For each item in the list, the associated user interface file has to be loaded, parsed and rendered, possibly many times per second. Channels hold potentially several thousand of torrents which should be displayed in a timely matter in the user interface.\\\\
This scalability bottleneck has been solved by using a simple technique: lazy loading. By taking advantage of a lazy-loading approach where more data is loaded in chunks when the user has scrolled to the end of the list, we can postpone and possibly avoid loading the whole list at once. This solution has also been implemented in the old interface. By loading only a subset of the list rows, the user experience can be significantly increased since users don't have to wait until the whole list of items is loaded, at the cost of a small delay when the end of the list is reached. The implementation of this lazy-loading solution is reusable and can be found in the \emph{lazyloadlist.py} source file. This however, still resulted in a significant period of waiting when the next set of items is being loaded, around one second. It turned out that loading and parsing of the interface definition file is a time-consuming operation. The implemented solution to reduce this processing time is to pre-load the interface definition as soon the user interface starts. This has only a minor effect on the total start-up time (around 40 milliseconds on a high-end iMac device).

\subsubsection{\textbf{A function multi-platform video player}}
The embedded video player in the old interface did not function correctly on MacOS due to incompatibilities with the wx library used. The video player has been implemented using the popular VLC library\cite{vlcwebsite}, s a free and open source cross-platform multimedia player and framework that plays most media files. We started the design of the new user interface by creating a prototype where the implementation of a cross-platform, embedded video player with support for starting and stopping a video is centrally involved. While example code was available for the PyQt4 library using VLC bindings, there were some minor quirks when implementing the video player using PyQt5, mostly involved around obtaining a reference to the frame of the video player (which should be done differently for each platform). The code for this player has been used as reference for the implementation of the video player in the new user interface of Tribler and is available as open-source project on GitHub\cite{vos2016vlc}.

\section{Threading model improvements}
In Section \ref{subsec:architecture-twisted}, we discussed that the current threading model is complex and prone to errors by developers. The implementation of a new user interface and a RESTful API as described in the last sections, has led to a better and stable threading model. Now that the user interface runs in a separate, dedicated process and because of the removal of \emph{wxPython} from Tribler, we have the ability to run the Twisted reactor on the main thread. This allows us to get rid of confusing decorators to switch between the main and reactor thread since we only have one thread (besides the threadpool) to schedule calls on. Getting rid of the abundant thread switching should increase performance since we avoid overhead introduced by the context switch. The new, simplified threading model is visible in Figure \ref{fig:new-threading-model}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\columnwidth]{images/improving_qa/new_threading_model_tribler}
	\caption{The new, simplified threading model in Tribler 7, together with the primitives to schedule operations on the threadpool.}
	\label{fig:new-threading-model}
\end{figure}

\section{Relevance ranking algorithm}
\label{sec:relevance-ranking-algorithm}
Serving users relevant information as fast as possible is important in Tribler. When users are performing a search in the user interface, the returned search results are sorted according to a relevance ranking algorithm that considers several factors of the search results. A key problem of this algorithm is that the implementation is located inside the code base associated with the user interface. Essentially, sorting search results can be considered a task of the Tribler core. Moving the algorithm to the core module seems to be a adequate solution but this requires us to understand the old relevance ranking rules so we can reimplement the algorithm in the core module. Unfortunately, the code that is responsible for the relevance ranking lacks proper documentation and is hard to read and understand. Moreover, the code it split between several classes, making it harder to understand its behaviour.

\subsection{Old ranking algorithm}
Sorting of channels and torrents are both using a different algorithm. Channels are sorted on the number of torrents where channels that have a higher number of torrents, are displayed higher in the list. The algorithm to sort torrents on relevance is more complex and uses five different scores. These scores are determined as follows (ordered on importance):
\begin{enumerate}
	\item The number of matching keywords in the name of the torrent. Keywords are determined by splitting the name of a torrent on non-alphabetical characters and common keywords such as \emph{the} are filtered out.
	\item The position of the lowest matching keyword in the torrent name. For instance, when searching for \emph{One} and there is a torrent result named \emph{Pioneer-One-S01E03.avi}, the position of the lowest matching keyword is 2, since \emph{Pioneer} is not present in the search query.
	\item The number of matching keywords in the file names that the torrent contains.
	\item The number of matching keywords in the extension of the files (for instance, \emph{avi}, \emph{iso} etc).
	\item A score that is based on several (normalised) attributes of the torrent. This score is determined after the set of local search results are constructed. To calculate this score, the following formula is used: $ s = 0.8 * n_s - 0.1 * n_{vn} + 0.1 * n_{vp} $ where $ s $ is our score, $ n_s $ denotes the number of seeders (0 if this information is not available yet), $ n_{vn} $ the number of negatives votes of this torrent and $ n_{vp} $ the amount of positive votes this torrent has received. We should note that the number of positive and negative votes do not exist any more and as a consequence will always be 0, making this score only dependent on the number of seeders. The normalization process calculates the standard score for every data item, using the following formula:
	
	\begin{equation}
	\label{eq:normalization-standard-score}
	z = \frac{x - \mu}{\sigma}
	\end{equation}
	
	where $ z $ is our normalized score, $ x $ the score to be normalized, $ \mu $ the mean of the data set and $ \sigma $ the standard deviation of the data set.
	
\end{enumerate}
For each torrent, the set of five scores as described above is determined. The comparison between two torrents now proceeds based on these five determined scores, starting with the first score, proceeding to the next score in case when two scores are equal.\\\\
Finally, the list is prepared and a channel result is inserted between every five torrent items in the list. This is done since usually, the amount of torrents is much bigger than the amount of channels. Not only channels matching the search query are displayed: for each torrent, the most popular channel that contains this specific torrent, is determined and also considered in the list of results.\\\\
While the algorithm as described above takes many factors in consideration, we detected some problems and possible improvements:
\begin{itemize}
	\item One of the main problem is that the amount of matches inside a torrent name/torrent file name is not taken into consideration. For instance, when searching for \emph{Pioneer One}, a torrent named \emph{Pioneer One Collection} probably has a higher relevance than a torrent named \emph{Pioneer One - Episode 3, Season 4} since the matching in the first case is considered better.
	\item The relevance sorting of channels in the result set is only dependent on the number of torrents in that channel. The number of matching terms in the channel name and description is not even considered.
	\item When building the inverted index in the SQLite database for the full text search, duplicate words are removed. This means that when we search for \emph{years}, a torrent named \emph{best years} will be ranked equal to a torrent named \emph{years and years} (if we only consider a ranking based on the torrent name). However, the torrent named \emph{years and years} should be assigned a higher relevance since the keyword \emph{years} occurs twice in the latter example. Another example is when searching for \emph{iso}. A torrent file that contains 100 \emph{iso} files is currently ranked equivalent to a torrent file that only has one \emph{iso} file.
	\item The current relevance ranking algorithm only returns results that matches all given keywords. So when searching for \emph{pirate audio}, only torrents are returned that are matching on both terms. It might be better to show the user also torrents matching 'pirate' and matching 'audio' (while still giving a higher relevance score to torrents that matches 'pirate audio').
	\item The ranking of search results are dependent on each other. This is noticeable when calculating the score based on normalized data. To normalize this data, we should have information about other search results. This prevents a "streaming-like" search operation where the relevance score of each search item is only dependent on data that search item contains and no other data.
\end{itemize}

\subsection{Designing a new ranking algorithm}
In the previous Subsection, we described the old ranking algorithm, together with some problems and improvements. In this Subsection, we will design a new, robust and simplified algorithm. The heart of the algorithm will be based on Okapi BM25, a ranking function used by search engines to rank matching documents according to their relevance to a given search query\cite{jones2000probabilistic}. BM25 can be implemented using the following formula:

\begin{equation}
\label{eq:bm25}
s = \sum_{i=1}^{n} IDF(q_i) \frac{f(q_i, D)(k_1 + 1)}{f(q_i, D) + k_1 (1 - b + b * \frac{|D|}{avgdl})}
\end{equation}

In the formula above, we have a document $ D $ where the length of $ D $ is denoted as $ |D| $. There are $ n $ keywords present in our search query, $ q_i $ representing the keyword at index $ i $. $ f(\cdot, D) $ gives the frequency of keyword $ q_i $ in document $ D $. The $ IDF(q_i) $ denotes the \emph{inversed document frequency} of keyword $ q_i $ which basically states how important a keyword is in a document. The IDF is usually calculated as:

\begin{equation}
\label{eq:bm25-idf}
IDF(q_i) = log\frac{N - n(q_i) + 0.5}{n(q_i) + 0.5}
\end{equation}

where $ N $ is the total number of documents and $ n(q_i) $ is the number of documents containing keyword $ q_i $. The full text search engine in SQLite offers tools to easily calculate a BM25 score when performing a query. Unfortunately, this is not implemented in the engine we are currently using, FTS3. This motivates us to upgrade to a newer engine, FTS4, which offers the necessary tools to easily calculate the BM25 score. This requires a one-time upgrade of the database engine of users which should be performed when Tribler starts.\\\\
Each search result is assigned a relevance score. The final relevance score assigned to a torrent is dependent on three other sub-scores that are calculated using the BM25 algorithm and is a weighted average of the sub-scores, determined by the name of the torrent (80\%), the file names of the torrent (10\%) and the file extensions of the torrent (10\%). The final relevance score of a channel is the weighted average of the BM25 score of the name of the channel (80\%) and the description of the channel (20\%).\\\\
While this works well when searching for local search results, we should also be able to assign a relevance rank to incoming remote torrent or channel results. To do this, we keep track of the latest local searches and the gathered information that is used by Equations \ref{eq:bm25} and \ref{eq:bm25-idf}. If we receive an incoming search result, we are using that stored information to quickly determine the relevance score of the remote result. Using this approach, we avoid a lookup in the database for every incoming remote search result. If we have no information about the latest local database lookup available, we assign a relevance score of 0 to the remote result.

\subsection{Ranking in the user interface}
After each search result got a relevance score assigned, we should order the search results in the user interface. We cannot make the assumption that the data we receive from Tribler is already sorted (however, a relevance score should be available) thus we need a way to insert items dynamically in the list. The lazy-loading list we are using in the user interface makes this task more difficult since we both have to insert items dynamically in the list and make sure that we are not rendering too much row widgets. We also wish to avoid reordering operations as they are computational expensive to perform.\\\\
The implemented solution works as follows: in the user interface, we maintain two lists in memory: one list that contains the torrent search results and another list that contains channel search results. We guarantee that these lists are always sorted on relevance score. Insert operations in this list are performed using a binary search to determine the new position of the item in the sorted list, leading to a complexity of $ O(log\ n) $ for each insert operation (where $ n $ is the number of items in the list). In the visible result list, we first display channels, which are usually only a few. The rationale behind this idea is that users prefer to see matching channels since these channels might contain many relevant torrents. This solution is scalable to many search results. The performance of the new relevance ranking algorithm is discussed in Chapter \ref{sec:local-content-search}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=1.0\columnwidth]{images/improving_qa/qt_designer}
	\caption{The Qt visualizer tool used to create the new user interface of Tribler.}
	\label{fig:qt-visualizer}
\end{figure}